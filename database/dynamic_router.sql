/*
GROUP HEADERS GENERATED BY: https://patorjk.com/software/taag/#p=display&h=0&v=1&c=c&f=ANSI%20Shadow&t=STAGE%20FUNCS
*/

create extension if not exists "uuid-ossp" schema ext;
create extension if not exists ltree schema ext;
create extension if not exists unaccent schema ext;

/***
*    ██╗--██╗███████╗██╗-----██████╗-███████╗██████╗-███████╗
*    ██║--██║██╔════╝██║-----██╔══██╗██╔════╝██╔══██╗██╔════╝
*    ███████║█████╗--██║-----██████╔╝█████╗--██████╔╝███████╗
*    ██╔══██║██╔══╝--██║-----██╔═══╝-██╔══╝--██╔══██╗╚════██║
*    ██║--██║███████╗███████╗██║-----███████╗██║--██║███████║
*    ╚═╝--╚═╝╚══════╝╚══════╝╚═╝-----╚══════╝╚═╝--╚═╝╚══════╝
*    --------------------------------------------------------
*/

create function helpers.random_string(len integer DEFAULT 36) returns text
    stable
    cost 1
    language sql
as
$$
select upper(substring(md5(random()::text), 0, len + 1));
$$;

create function helpers.normalize_text(_text text)
    returns text
    stable RETURNS NULL ON NULL INPUT
    language sql
as
$$
select case when _text is null then null else ext.unaccent(lower(_text)) end;
$$;

create function helpers.get_code(_title text)
    returns text
    stable RETURNS NULL ON NULL INPUT
    language sql
as
$$
select case when _title is null then null else replace(helpers.normalize_text(_title), ' ', '_') end;
$$;

create function helpers.get_slug(_title text)
    returns text
    stable RETURNS NULL ON NULL INPUT
    language sql
as
$$
select case when _title is null then null else replace(helpers.normalize_text(_title), ' ', '-') end;
$$;

create function helpers.ltree_parent(path ext.ltree, levels integer DEFAULT 1) returns ext.ltree
    language plpgsql
as
$$
begin
    return ext.subpath(path, 0, ext.nlevel(path) - levels);
end
$$;

/***
 *     ██████╗ ██████╗ ███╗   ██╗███████╗████████╗ █████╗ ███╗   ██╗████████╗███████╗
 *    ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔══██╗████╗  ██║╚══██╔══╝██╔════╝
 *    ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████║██╔██╗ ██║   ██║   ███████╗
 *    ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║╚██╗██║   ██║   ╚════██║
 *    ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ██║  ██║██║ ╚████║   ██║   ███████║
 *     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
 *                                                                                   
 */

create table const.language
(
    language_id int generated always as identity primary key not null,
    code        text check (length(code) = 5) unique         not null,
    name        text                                         not null
);

create table const.language_variant
(
    lv_id           int generated always as identity primary key not null,
    language_id     int references const.language (language_id) on delete cascade on update cascade,
    is_root         bool default true,
    domain          text                                         not null,
    domain_redirect text default null,
    route_code      text default null,
    is_default      bool default false
);

create table const.controller
(
    controller_id int generated always as identity primary key not null,
    code          text unique not null,
    name text not null
);

create table const.route_map
(
    lv_id           int generated always as identity primary key not null,
    language_id     int references const.language (language_id) on delete cascade on update cascade,
    route_path      text not null,
    controller_id   int references const.controller (controller_id) on delete cascade on update cascade
);

create table const.article_state
(
    code  text primary key not null,
    title text             not null
);

create table const.nav_state
(
    code  text primary key not null,
    title text             not null
);

create table const.nav_type
(
    code  text primary key not null,
    title text             not null
);


/***
 *    ████████╗███████╗███╗---███╗██████╗-██╗------█████╗-████████╗███████╗███████╗
 *    ╚══██╔══╝██╔════╝████╗-████║██╔══██╗██║-----██╔══██╗╚══██╔══╝██╔════╝██╔════╝
 *    ---██║---█████╗--██╔████╔██║██████╔╝██║-----███████║---██║---█████╗--███████╗
 *    ---██║---██╔══╝--██║╚██╔╝██║██╔═══╝-██║-----██╔══██║---██║---██╔══╝--╚════██║
 *    ---██║---███████╗██║-╚═╝-██║██║-----███████╗██║--██║---██║---███████╗███████║
 *    ---╚═╝---╚══════╝╚═╝-----╚═╝╚═╝-----╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝╚══════╝
 *    -----------------------------------------------------------------------------
 */

create table public._template_created
(
    created    timestamp with time zone               default now()                        not null,
    created_by text check (length(created_by) <= 250) default 'unknown'::character varying not null
);

create table public._template_timestamps
(
    modified    timestamp with time zone                default now()                        not null,
    modified_by text check (length(modified_by) <= 250) default 'unknown'::character varying not null
) inherits (_template_created);

create table public._template_code_value
(
    code  text not null primary key,
    value text not null
);

/***
 *    ████████╗██████╗-██╗-██████╗--██████╗-███████╗██████╗-███████╗
 *    ╚══██╔══╝██╔══██╗██║██╔════╝-██╔════╝-██╔════╝██╔══██╗██╔════╝
 *    ---██║---██████╔╝██║██║--███╗██║--███╗█████╗--██████╔╝███████╗
 *    ---██║---██╔══██╗██║██║---██║██║---██║██╔══╝--██╔══██╗╚════██║
 *    ---██║---██║--██║██║╚██████╔╝╚██████╔╝███████╗██║--██║███████║
 *    ---╚═╝---╚═╝--╚═╝╚═╝-╚═════╝--╚═════╝-╚══════╝╚═╝--╚═╝╚══════╝
 *    --------------------------------------------------------------
 */

CREATE OR REPLACE FUNCTION trg_generate_code_from_title()
    RETURNS trigger
    LANGUAGE plpgsql AS
$$
BEGIN
    NEW.code := get_code(NEW.title);

    RETURN NEW;
END
$$;

create or replace function trg_generate_slug_from_title()
    RETURNS trigger
    LANGUAGE plpgsql AS
$$
BEGIN
    NEW.slug := get_slug(NEW.title);

    RETURN NEW;
END
$$;

/***
 *    ███████╗███████╗████████╗████████╗██╗███╗   ██╗ ██████╗ ███████╗
 *    ██╔════╝██╔════╝╚══██╔══╝╚══██╔══╝██║████╗  ██║██╔════╝ ██╔════╝
 *    ███████╗█████╗     ██║      ██║   ██║██╔██╗ ██║██║  ███╗███████╗
 *    ╚════██║██╔══╝     ██║      ██║   ██║██║╚██╗██║██║   ██║╚════██║
 *    ███████║███████╗   ██║      ██║   ██║██║ ╚████║╚██████╔╝███████║
 *    ╚══════╝╚══════╝   ╚═╝      ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝
 *
 */

create table public.settings
(
    settings_id int generated always as identity not null primary key,
    code        text unique                      not null,
    value       text                             not null
);

/***
 *     █████╗ ██████╗ ████████╗██╗ ██████╗██╗     ███████╗███████╗
 *    ██╔══██╗██╔══██╗╚══██╔══╝██║██╔════╝██║     ██╔════╝██╔════╝
 *    ███████║██████╔╝   ██║   ██║██║     ██║     █████╗  ███████╗
 *    ██╔══██║██╔══██╗   ██║   ██║██║     ██║     ██╔══╝  ╚════██║
 *    ██║  ██║██║  ██║   ██║   ██║╚██████╗███████╗███████╗███████║
 *    ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝╚══════╝╚══════╝╚══════╝
 *
 */

create table module
(
    module_id int,
    title     text,
    module    text,
    method    text
);

create table category
(
    category_id int generated always as identity not null primary key,
    node_path   ext.ltree,
    add_content jsonb
) inherits (_template_timestamps);

create table category_content
(
    cc_id       int generated always as identity not null primary key,
    category_id int                              not null references category (category_id) on delete cascade on update cascade,
    language_id int references const.language (language_id) on delete cascade on update cascade,
    title       text                             not null,
    slug        text,
    content     text,
    keywords    text,
    description text
) inherits (_template_timestamps);

create table article
(
    article_id        int generated always as identity not null primary key,
    category_id       int,
    article_type_code text, -- Static/Dynamic
    gallery_id        int,
    article_code      text -- ?
) inherits (_template_timestamps);

create table article_content
(
    ac_id       int generated always as identity not null primary key,
    language_id int references const.language (language_id) on delete cascade on update cascade,
    article_id  int                              not null references article (article_id) on delete cascade on update cascade,
    state_code  text                             not null references const.article_state (code) default 'DRAFT',
    route_code  text, -- ?
    slug        text,
    title       text                             not null,
    content     text,
    keywords    text,
    description text,
    gallery_id  int,
    add_content jsonb
) inherits (_template_timestamps);

/***
*     ██████╗  █████╗ ██╗     ██╗     ███████╗██████╗ ██╗   ██╗
*    ██╔════╝ ██╔══██╗██║     ██║     ██╔════╝██╔══██╗╚██╗ ██╔╝
*    ██║  ███╗███████║██║     ██║     █████╗  ██████╔╝ ╚████╔╝
*    ██║   ██║██╔══██║██║     ██║     ██╔══╝  ██╔══██╗  ╚██╔╝
*    ╚██████╔╝██║  ██║███████╗███████╗███████╗██║  ██║   ██║
*     ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚═╝  ╚═╝   ╚═╝
*
*/

create table public.photo
(
    photo_id  int generated always as identity      not null primary key,
    code      text default helpers.random_string(6) not null,
    width     integer                               not null,
    height    integer                               not null,
    file_size bigint                                not null
);


create table public.gallery_photo
(
    gallery_photo_id int generated always as identity not null primary key,
    gallery_id       integer                          not null,
    photo_id         integer                          not null
);

create table public.gallery
(
    gallery_id int generated always as identity not null primary key,
    code       text unique                      not null,
    title_cs   text,
    title_en   text
);

/***
 *    ███████╗██╗██╗     ███████╗███████╗
 *    ██╔════╝██║██║     ██╔════╝██╔════╝
 *    █████╗  ██║██║     █████╗  ███████╗
 *    ██╔══╝  ██║██║     ██╔══╝  ╚════██║
 *    ██║     ██║███████╗███████╗███████║
 *    ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝
 *                                       
 */
create table file
(
    file_id      int generated always as identity not null primary key,
    code         text                             not null default helpers.random_string(8) unique,
    filename     text,
    size         bigint,
    content_type text,
    location     text
) inherits (_template_timestamps);


/***
 *     ██████╗ ██████╗ ███╗   ██╗███████╗████████╗ █████╗ ███╗   ██╗████████╗███████╗
 *    ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔══██╗████╗  ██║╚══██╔══╝██╔════╝
 *    ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████║██╔██╗ ██║   ██║   ███████╗
 *    ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║╚██╗██║   ██║   ╚════██║
 *    ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ██║  ██║██║ ╚████║   ██║   ███████║
 *     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
 *                                                                                   
 */

 create or replace function const.get_language_variants()
    returns table
            (
                __lv_id           int,
                __language_id     int,
                __is_root         bool,
                __domain          text,
                __domain_redirect text,
                __route_code      text,
                __is_default      bool,
                __language_code   text
            )
    language sql
as
$$
select lv_id,
       const.language.language_id,
       is_root,
       domain,
       domain_redirect,
       route_code,
       is_default,
       language.code language_code
from const.language_variant
         inner join const.language on const.language_variant.language_id = const.language.language_id
$$;

create function get_language(_language_code text)
    returns setof const.language
    language sql
as
$$
    select * from const.language where code = _language_code;
$$;

/***
 *    ███████╗███████╗████████╗████████╗██╗███╗   ██╗ ██████╗ ███████╗
 *    ██╔════╝██╔════╝╚══██╔══╝╚══██╔══╝██║████╗  ██║██╔════╝ ██╔════╝
 *    ███████╗█████╗     ██║      ██║   ██║██╔██╗ ██║██║  ███╗███████╗
 *    ╚════██║██╔══╝     ██║      ██║   ██║██║╚██╗██║██║   ██║╚════██║
 *    ███████║███████╗   ██║      ██║   ██║██║ ╚████║╚██████╔╝███████║
 *    ╚══════╝╚══════╝   ╚═╝      ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝
 *                                                                    
 */

create or replace function public.get_all_settings() RETURNS SETOF public.settings
    LANGUAGE sql
AS
$$
select *
from settings;
$$;

create or replace function public.remove_settings(_settings_id integer) RETURNS SETOF public.settings
    LANGUAGE sql
AS
$$
delete
from settings
where settings_id = _settings_id
returning *;
$$;

create or replace function public.save_settings(_code text, _value text, _settings_id integer DEFAULT NULL::integer) RETURNS SETOF public.settings
    LANGUAGE plpgsql
AS
$$
begin
    if _settings_id is null then
        return query
            insert into settings (code, value) values (_code, _value)
                returning *;
    else
        return query
            update settings set code = _code, value = _value where settings_id = _settings_id
                returning *;
    end if;
end
$$;

/***
 *     █████╗ ██████╗ ████████╗██╗ ██████╗██╗     ███████╗███████╗
 *    ██╔══██╗██╔══██╗╚══██╔══╝██║██╔════╝██║     ██╔════╝██╔════╝
 *    ███████║██████╔╝   ██║   ██║██║     ██║     █████╗  ███████╗
 *    ██╔══██║██╔══██╗   ██║   ██║██║     ██║     ██╔══╝  ╚════██║
 *    ██║  ██║██║  ██║   ██║   ██║╚██████╗███████╗███████╗███████║
 *    ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝╚══════╝╚══════╝╚══════╝
 *                                                                
 */

--categories
create trigger c_category_content_slug
    before insert
    on public.category_content
    for each row
execute procedure trg_generate_slug_from_title();

create trigger u_category_content_slug
    before update
    on public.category_content
    for each row
execute procedure trg_generate_slug_from_title();

create or replace function create_category(_created_by text,
                                          _language_id int, _title text, _content text, _keywords text, _description text)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __language_id       int,
                __title             text,
                __slug              text,
                __content           text,
                __keywords          text,
                __description       text
            )
    language plpgsql
as
$$
declare
    __category_id int;
    __cc_id int;
begin
    insert into category (created_by, modified_by)
    values (_created_by, _created_by)
    returning category_id into __category_id;

    insert into category_content(created_by, modified_by, language_id, category_id, title, content, keywords, description)
    values (_created_by, _created_by, _language_id, __category_id, _title, _content, _keywords, _description)
    returning cc_id into __cc_id;

    return query
    select  cc.created
           ,cc.created_by
           ,cc.modified
           ,cc.modified_by
           ,c.category_id
           ,cc.language_id
           ,cc.title
           ,cc.slug
           ,cc.content
           ,cc.keywords
           ,cc.description
    from category c
    inner join category_content cc on c.category_id = cc.category_id
    where c.category_id = __category_id;
end;
$$;

create or replace function update_category(_category_id int, _created_by text, 
                                          _cc_id int, _language_id int, _title text, _content text, _keywords text, _description text)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __language_id       int,
                __title             text,
                __slug              text,
                __content           text,
                __keywords          text,
                __description       text
            )
    language plpgsql
as
$$
begin
    update category 
    set  created_by = _created_by
        ,modified_by = _created_by
    where category_id = _category_id;

    if exists(select 1 from category_content where cc_id = _cc_id)
        then
            update category_content
            set  created_by = _created_by
                ,modified_by = _created_by
                ,language_id = _language_id
                ,title = _title
                ,content = _content
                ,keywords = _keywords
                ,description = _description
            where cc_id = _cc_id;
        else
            insert into category_content(created_by, modified_by, category_id, language_id, title, content, keywords, description)
            values (_created_by, _created_by, _category_id, _language_id, _title, _content, _keywords, _description);   
    end if;
  
    return query
    select  cc.created
           ,cc.created_by
           ,cc.modified
           ,cc.modified_by
           ,c.category_id
           ,cc.language_id
           ,cc.title
           ,cc.slug
           ,cc.content
           ,cc.keywords
           ,cc.description
    from category c
    inner join category_content cc on c.category_id = cc.category_id
    where c.category_id = _category_id and cc.language_id = _language_id;
end;
$$;

create or replace function get_all_categories()
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __category_content   jsonb
            )
    language sql
as
$$
select  c.created
       ,c.created_by
       ,c.modified
       ,c.modified_by
       ,c.category_id
       ,(
            select json_object_agg(d.language_id, row_to_json(d))
            from (
                        select l.language_id, l.code, cc.title
                        from language l
                        left join category_content cc on l.language_id = cc.language_id
                        where cc.category_id = c.category_id
                    ) d
        ) as category_content
    from category c
$$;

create or replace function get_category(_category_id int)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __category_content   jsonb

            )
    language sql
as
$$
select  c.created
       ,c.created_by
       ,c.modified
       ,c.modified_by
       ,c.category_id
       ,(
           select json_object_agg(d.language_id, row_to_json(d))
           from (
                    select *
                    from category_content cc
                    where cc.category_id = c.category_id
                ) d
       ) as category_content
from category c
where c.category_id = _category_id
limit 1
$$;

create or replace function delete_category(_category_id int)
    returns table
            (
                __created     timestamptz,
                __created_by  text,
                __modified    timestamptz,
                __modified_by text,
                __category_id int
            )
    language plpgsql
as
$$
begin
    return query
        delete
            from category
                where category_id = _category_id
                returning created, created_by, modified, modified_by, category_id;
end;
$$;

-- articles
create trigger c_article_content_slug
    before insert
    on public.article_content
    for each row
execute procedure trg_generate_slug_from_title();

create trigger u_article_content_slug
    before update
    on public.article_content
    for each row
execute procedure trg_generate_slug_from_title();

create or replace function create_article(_created_by text, _user_id int, _category_id int, _type_code text, 
                                          _language_id int, _title text, _content text)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __article_type_code text,
                __gallery_id        int,
                __article_code      text,
                __language_id       int,
                __article_id        int,
                __title             text,
                __slug              text,
                __content           text,
                __keywords          text,
                __description       text,
                __state_code        text
            )
    language plpgsql
as
$$
declare
    __article_id int;
    __ac_id int;
begin
    insert into article (created_by, modified_by, category_id, article_type_code)
    values (_created_by, _created_by, _category_id, _type_code)
    returning article_id into __article_id;

    insert into article_content(created_by, modified_by, language_id, article_id, title, content)
    values (_created_by, _created_by, _language_id, __article_id, _title, _content)
    returning ac_id into __ac_id;

    return query
    select  ac.created
           ,ac.created_by
           ,ac.modified
           ,ac.modified_by
           ,a.category_id
           ,a.article_type_code
           ,a.gallery_id
           ,a.article_code
           ,ac.language_id
           ,ac.article_id
           ,ac.title
           ,ac.slug
           ,ac.content
           ,ac.keywords
           ,ac.description
           ,ac.state_code
    from article a
    inner join article_content ac on a.article_id = ac.article_id
    where a.article_id = __article_id;
end;
$$;

create or replace function update_article(_article_id int, _created_by text, _user_id int, _category_id int, _type_code text, 
                                          _ac_id int, _language_id int, _title text, _content text)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __category_id       int,
                __article_type_code text,
                __gallery_id        int,
                __article_code      text,
                __language_id       int,
                __article_id        int,
                __title             text,
                __slug              text,
                __content           text,
                __keywords          text,
                __description       text,
                __state_code        text
            )
    language plpgsql
as
$$
begin
    update article 
    set  created_by = _created_by
        ,modified_by = _created_by
        ,category_id = _category_id
    where article_id = _article_id;


  if exists(select 1 from article_content where ac_id = _ac_id)
    then
        update article_content
        set  created_by = _created_by
            ,modified_by = _created_by
            ,language_id = _language_id
            ,title = _title
            ,content = _content
        where ac_id = _ac_id;
    else
        insert into article_content(created_by, modified_by, language_id, article_id, title, content)
        values (_created_by, _created_by, _language_id, _article_id, _title, _content);   
    end if;
  
    return query
    select  ac.created
           ,ac.created_by
           ,ac.modified
           ,ac.modified_by
           ,a.category_id
           ,a.article_type_code
           ,a.gallery_id
           ,a.article_code
           ,ac.language_id
           ,ac.article_id
           ,ac.title
           ,ac.slug
           ,ac.content
           ,ac.keywords
           ,ac.description
           ,ac.state_code
    from article a
    inner join article_content ac on a.article_id = ac.article_id
    where a.article_id = _article_id and ac.language_id = _language_id;
end;
$$;


create or replace function get_all_articles()
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __article_id        int,
                __category_id       int,
                __article_type_code text,
                __gallery_id        int,
                __article_code      text,
                __article_content   jsonb
            )
    language sql
as
$$
select  a.created
       ,a.created_by
       ,a.modified
       ,a.modified_by
       ,a.article_id
       ,a.category_id
       ,a.article_type_code
       ,a.gallery_id
       ,a.article_code
       ,(
            select json_object_agg(d.language_id, row_to_json(d))
            from (
                        select l.language_id, l.code, ac.title
                        from language l
                        left join article_content ac on l.language_id = ac.language_id
                        where ac.article_id = a.article_id
                    ) d
        ) as article_content
    from article a
$$;

create or replace function get_article(_article_id int)
    returns table
            (
                __created           timestamptz,
                __created_by        text,
                __modified          timestamptz,
                __modified_by       text,
                __article_id        int,
                __category_id       int,
                __article_type_code text,
                __gallery_id        int,
                __article_code      text,
                __article_content   jsonb

            )
    language sql
as
$$
select  a.created
       ,a.created_by
       ,a.modified
       ,a.modified_by
       ,a.article_id
       ,a.category_id
       ,a.article_type_code
       ,a.gallery_id
       ,a.article_code
       ,(
           select json_object_agg(d.language_id, row_to_json(d))
           from (
                    select *
                    from article_content ac
                    where ac.article_id = a.article_id
                ) d
       ) as article_content
from article a
where a.article_id = _article_id
limit 1
$$;

create or replace function delete_article(_article_id int)
    returns table
            (
                __created     timestamptz,
                __created_by  text,
                __modified    timestamptz,
                __modified_by text,
                __article_id  int,
                __category_id  int,
                __article_type_code  text,
                __gallery_id  int,
                __article_code  text
            )
    language plpgsql
as
$$
begin
    return query
        delete
            from article
                where article_id = _article_id
                returning created, created_by, modified, modified_by, article_id, category_id, article_type_code, gallery_id, article_code;
end;
$$;


/***
 *    ███╗   ██╗ █████╗ ██╗   ██╗██╗ ██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗
 *    ████╗  ██║██╔══██╗██║   ██║██║██╔════╝ ██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║
 *    ██╔██╗ ██║███████║██║   ██║██║██║  ███╗███████║   ██║   ██║██║   ██║██╔██╗ ██║
 *    ██║╚██╗██║██╔══██║╚██╗ ██╔╝██║██║   ██║██╔══██║   ██║   ██║██║   ██║██║╚██╗██║
 *    ██║ ╚████║██║  ██║ ╚████╔╝ ██║╚██████╔╝██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║
 *    ╚═╝  ╚═══╝╚═╝  ╚═╝  ╚═══╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝
 *
 */

create table nav
(
    nav_id         int generated always as identity primary key not null,
    code           text                                         not null unique,
    nav_state_code text                                         not null references const.nav_state (code) default 'HIDDEN',
    title          text                                         not null
) inherits (_template_timestamps);

create table nav_item
(
    nav_item_id        int generated always as identity primary key not null,
    nav_id             int references nav (nav_id),
    language_id        int                                          not null references const.language (language_id),
    nav_state          text                                         not null references const.nav_state (code) default 'HIDDEN',
    nav_type           text                                         not null references const.nav_type (code)  default 'STATPAGE',
    node_path          ext.ltree,
    title              text                                         null,
    url                text,
    article_content_id int,
--     page_id     int4 references page (page_id) on delete set null on update cascade,
    priority           int                                          not null                                   default 0
) inherits (_template_timestamps);


/***
 *    ███╗   ██╗ █████╗ ██╗   ██╗██╗ ██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗
 *    ████╗  ██║██╔══██╗██║   ██║██║██╔════╝ ██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║
 *    ██╔██╗ ██║███████║██║   ██║██║██║  ███╗███████║   ██║   ██║██║   ██║██╔██╗ ██║
 *    ██║╚██╗██║██╔══██║╚██╗ ██╔╝██║██║   ██║██╔══██║   ██║   ██║██║   ██║██║╚██╗██║
 *    ██║ ╚████║██║  ██║ ╚████╔╝ ██║╚██████╔╝██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║
 *    ╚═╝  ╚═══╝╚═╝  ╚═╝  ╚═══╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝
 *
 */

create function public.create_nav(_created_by text, _user_id int, _code text, _title text,
                                  _nav_state_code text default 'HIDDEN')
    returns setof nav
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.create_navigation');

    return query
        insert into nav (created_by, modified_by, code, nav_state_code, title)
            values (_created_by, _created_by, _code, _nav_state_code, _title)
            returning *;
end;
$$;

create function public.update_nav(_modified_by text, _user_id int, _nav_id int, _code text, _title text,
                                  _nav_state_code text default 'HIDDEN')
    returns setof nav
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.edit_navigation');

    return query
        update nav
            set modified_by = _modified_by,
                modified = now(),
                code = _code,
                title = _title,
                nav_state_code = _nav_state_code
            where nav_id = _nav_id
            returning *;
end;
$$;

create function public.delete_nav(_deleted_by text, _user_id int, _nav_id int)
    returns setof nav
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.remove_navigation');

    delete
    from nav_item
    where nav_id = _nav_id;

    return query
        delete from nav
            where nav_id = _nav_id
            returning *;
end;
$$;

create function public.set_nav_visibility(_modified_by text, _user_id int, _nav_id int,
                                          _nav_state_code text default 'HIDDEN')
    returns setof nav
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.edit_navigation');

    return query
        update nav
            set modified_by = _modified_by,
                modified = now(),
                nav_state_code = _nav_state_code
            where nav_id = _nav_id
            returning *;
end;
$$;

create function public.create_nav_item(_created_by text, _user_id int, _nav_id int, _language_id int, _title text
, _parent_item_id int default null::int
--                                       , _page_id int default null::int
, _url text default null::text
, _nav_type text default 'STATPAGE'
, _nav_state text default 'HIDDEN'
, _priority int default null::int)
    returns table
            (
                __created     timestamp with time zone,
                __created_by  text,
                __modified    timestamp with time zone,
                __modified_by text,
                __nav_item_id int,
                __nav_id      int,
                __language_id int,
                __nav_state   text,
                __nav_type    text,
                ___node_path  text,
                __title       text,
                __url         text,
                __priority    int
            )
    language plpgsql
as
$$
declare
    __new_id        int;
    __node_path     ext.ltree;
    __parent_path   ext.ltree;
    __last_priority int;
begin

    -- perform has_permission(_user_id, 'system.navigation.create_navigation_item');

    insert into nav_item( created_by, modified_by, nav_id, language_id, nav_state, nav_type
                        , title, url)
    values (_created_by, _created_by, _nav_id, _language_id, _nav_state, _nav_type, _title, _url)
    returning nav_item_id into __new_id;

    if _parent_item_id is not null then
        select node_path
        from nav_item
        where nav_item_id = _parent_item_id
        into __parent_path;

        __node_path := __parent_path || __new_id::text::ext.ltree;

    else
        __node_path := __new_id::text::ext.ltree;
    end if;

    select max(priority)
    from nav_item
    where (_parent_item_id is not null and node_path ~ (__parent_path::text || '.*{1}')::ext.lquery)
       or (_parent_item_id is null and ext.nlevel(node_path) = 1)
    into __last_priority;

    update nav_item
    set node_path = __node_path
      , priority  = coalesce(_priority, coalesce(__last_priority, 0) + 1)
    where nav_item_id = __new_id;

    return query
        select created,
               created_by,
               modified,
               modified_by,
               nav_item_id,
               nav_id,
               language_id,
               nav_state,
               nav_type,
               node_path::text,
               title,
               url,
               priority
        from nav_item
        where nav_item_id = __new_id;
end;
$$;

create function public.update_nav_item(_modified_by text
, _user_id int
, _nav_item_id integer
, _language_id int
, _nav_type text
, _nav_state text
, _title text default null
--                                       , _page_id int default null::int
, _url text default null::text)
    returns setof nav_item
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.edit_nav_item');

    return query
        update nav_item set
            modified_by = _modified_by,
            modified = now(),
            language_id = _language_id,
            title = _title,
--             page_id = _page_id,
            url = _url,
            nav_type = _nav_type,
            nav_state = _nav_state
            where nav_item_id = _nav_item_id
            returning *;
end;
$$;

create function public.delete_nav_item(_deleted_by text, _user_id int, _nav_item_path text)
    returns setof nav_item
    language plpgsql
as
$$
begin
    -- perform has_permission(_user_id, 'system.navigation.remove_nav_item');

    delete
    from nav_item
    where node_path @> _nav_item_path::ext.ltree;
end;
$$;

create function public.delete_nav_items(_deleted_by text, _user_id int, _nav_item_ids int[])
    returns setof nav_item
    language plpgsql
as
$$
begin

    -- perform has_permission(_user_id, 'system.navigation.remove_nav_item');

    with ni_to_remove as (select ni.node_path
                          from unnest(_nav_item_ids) id
                                   inner join nav_item ni on ni.nav_item_id = id.id)
    select
    from ni_to_remove nir, lateral delete_nav_item(_deleted_by, _user_id, nir.node_path);

end;
$$;

create or replace function get_navigation(_code text, _language_id int)
    returns table
            (
                __level       int,
                __parent_path text,
                __node_path   text,
                __nav_type    text,
                __title       text,
                __url         text,
--                 __seo_code    text,
                __priority    int
            )
    language sql
as
$$
select ext.nlevel(ni.node_path),
       helpers.ltree_parent(ni.node_path)::text,
       ni.node_path::text,
       ni.nav_type,
--        coalesce(ni.title, pp.title),
       ni.title,
       ni.url,
--        pp.seo_code,
       ni.priority
from nav n
         inner join nav_item ni on n.nav_id = ni.nav_id
--          left join published_pages pp on ni.page_id = pp.page_id
where n.code = _code
  and ni.language_id = _language_id
order by ext.nlevel(node_path), priority;

$$;


-- ROUTING --
-------------

create function get_controller(_route text, _language_id int)
    returns setof const.controller
    language sql
as
$$
select c.controller_id,
       c.name,
       c.code
from const.controller c
inner join const.route_map rm on rm.controller_id = c.controller_id
where rm.route_path = _route
  and rm.language_id = _language_id
limit 1;
$$;


/***
 *     ██████╗  █████╗ ██╗     ██╗     ███████╗██████╗ ██╗   ██╗
 *    ██╔════╝ ██╔══██╗██║     ██║     ██╔════╝██╔══██╗╚██╗ ██╔╝
 *    ██║  ███╗███████║██║     ██║     █████╗  ██████╔╝ ╚████╔╝ 
 *    ██║   ██║██╔══██║██║     ██║     ██╔══╝  ██╔══██╗  ╚██╔╝  
 *    ╚██████╔╝██║  ██║███████╗███████╗███████╗██║  ██║   ██║   
 *     ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚═╝  ╚═╝   ╚═╝   
 *                                                              
 */

 create or replace function public.add_gallery_photos(_gallery_id integer, _photo_ids integer[])
    RETURNS SETOF public.gallery_photo
    LANGUAGE sql
AS
$$
insert into gallery_photo(gallery_id, photo_id)
SELECT _gallery_id, photo_id
FROM unnest(_photo_ids) AS photo_id
returning *;
$$;

create or replace function public.get_all_galleries() RETURNS SETOF public.gallery
    LANGUAGE sql
AS
$$
select *
from gallery
order by code;
$$;

create or replace function public.get_gallery(_gallery_id integer) RETURNS SETOF public.gallery
    LANGUAGE sql
AS
$$
select *
from gallery
where gallery_id = _gallery_id
$$;

create or replace function public.get_gallery_photos(_code text)
    RETURNS TABLE
            (
                photo_id   integer,
                photo_code text,
                width      integer,
                height     integer,
                file_size  bigint
            )
    LANGUAGE sql
AS
$$
select p.photo_id, p.code, p.width, p.height, p.file_size
from gallery g
         inner join gallery_photo gp on g.gallery_id = gp.gallery_id
         inner join photo p on gp.photo_id = p.photo_id
where g.code = _code;
$$;

create or replace function public.remove_gallery(_gallery_id integer) RETURNS SETOF public.gallery
    LANGUAGE sql
AS
$$
delete
from gallery
where gallery_id = _gallery_id
returning *;
$$;

create or replace function public.remove_gallery_photos(_gallery_id integer, _photo_ids integer[]) RETURNS SETOF public.gallery_photo
    LANGUAGE sql
AS
$$
delete
from gallery_photo
where gallery_photo_id in (SELECT gallery_photo_id
                           FROM unnest(_photo_ids) AS pid
                                    inner join gallery_photo gp on gallery_id = _gallery_id and photo_id = pid)
returning *;
$$;

create or replace function public.save_gallery(_code text, _title_cs text, _title_en text,
                                               _gallery_id integer DEFAULT NULL::integer) RETURNS SETOF public.gallery
    LANGUAGE plpgsql
AS
$$
begin
    if _gallery_id is not null then
        return query
            with updated_data as (
                update gallery set
                    code = _code,
                    title_cs = _title_cs,
                    title_en = _title_en
                    where gallery_id = _gallery_id
                    returning *)
            select *
            from updated_data;
    else
        return query
            with inserted_data as (
                insert into gallery (code, title_cs, title_en) values (_code, _title_cs, _title_en)
                    returning *)
            select *
            from inserted_data;
    end if;
end
$$;

create or replace function public.add_photo(_code text, _width integer, _height integer, _file_size bigint)
    RETURNS SETOF public.photo
    LANGUAGE sql
AS
$$
insert into photo(code, width, height, file_size)
values (_code, _width, _height, _file_size)
returning *;
$$;

create or replace function public.get_all_photos() RETURNS SETOF public.photo
    LANGUAGE sql
AS
$$
select *
from photo
order by photo_id desc;
$$;

create or replace function public.get_gallery_photos(_code text)
    RETURNS TABLE
            (
                photo_id   integer,
                photo_code text,
                width      integer,
                height     integer,
                file_size  bigint
            )
    LANGUAGE sql
AS
$$
select p.photo_id, p.code, p.width, p.height, p.file_size
from gallery g
         inner join gallery_photo gp on g.gallery_id = gp.gallery_id
         inner join photo p on gp.photo_id = p.photo_id
where g.code = _code;
$$;

create or replace function public.get_random_photo(_code text) RETURNS public.photo
    LANGUAGE sql
AS
$$
select p.*
from gallery g
         inner join gallery_photo gp on g.gallery_id = gp.gallery_id
         inner join photo p on gp.photo_id = p.photo_id
where g.code = _code
order by random()
limit 1;
$$;

create or replace function public.get_top_photos(_how_many integer) RETURNS SETOF public.photo
    LANGUAGE sql
AS
$$
select *
from photo
order by photo_id
limit _how_many;
$$;

create or replace function public.remove_photo(_code text) RETURNS SETOF public.photo
    LANGUAGE sql
AS
$$
delete
from photo
where code = _code
returning *;
$$;


/***
 *    ███████╗██╗██╗     ███████╗███████╗
 *    ██╔════╝██║██║     ██╔════╝██╔════╝
 *    █████╗  ██║██║     █████╗  ███████╗
 *    ██╔══╝  ██║██║     ██╔══╝  ╚════██║
 *    ██║     ██║███████╗███████╗███████║
 *    ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝
 *                                       
 */

 create or replace function create_file(_user_id int
, _created_by text
, _comm_id int
, _filename text
, _size bigint
, _content_type text)
    returns setof file
    language plpgsql
    rows 1
as
$$
begin
    if _comm_id = 0 then
        return query
            select *
            from file
            where file_id = -1;
    else

        return query
            insert into file (created_by, modified_by, filename, size, content_type)
                values ( _created_by
                       , _created_by
                       , _filename
                       , _size
                       , _content_type)
                returning *;
    end if;
end;
$$;

create or replace function get_all_files()
    returns table
            (
                __code text
            )
    language sql
    stable
as
$$
select code
from file;
$$;


/***
 *    ██████╗--██████╗-███████╗████████╗-----██████╗██████╗-███████╗-█████╗-████████╗███████╗
 *    ██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝----██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝
 *    ██████╔╝██║---██║███████╗---██║-------██║-----██████╔╝█████╗--███████║---██║---█████╗--
 *    ██╔═══╝-██║---██║╚════██║---██║-------██║-----██╔══██╗██╔══╝--██╔══██║---██║---██╔══╝--
 *    ██║-----╚██████╔╝███████║---██║-------╚██████╗██║--██║███████╗██║--██║---██║---███████╗
 *    ╚═╝------╚═════╝-╚══════╝---╚═╝--------╚═════╝╚═╝--╚═╝╚══════╝╚═╝--╚═╝---╚═╝---╚══════╝
 *    ---------------------------------------------------------------------------------------
 */

create or replace function load_initial_data()
    returns setof int
    language plpgsql
as
$$
declare
    __last_id int;
begin

    insert into const.language(code, name) values ('cs-cz', 'Čeština');
    insert into const.language(code, name) values ('en-gb', 'English');
    insert into const.language(code, name) values ('de-de', 'German');
    insert into const.language(code, name) values ('fr-fr', 'French');

    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (1, true, 'localhost', null, 'cs-cz', true);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (2, false, 'localhost.en', null, 'en-gb', true);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (4, false, 'localhost.en', null, 'fr-fr', false);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (3, false, 'localhost.en', null, 'de-de', false);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (4, false, 'localhost.fr', 'localhost.en', 'fr-fr', false);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (3, false, 'localhost.de', 'localhost.en', 'de-de', false);
    insert into const.language_variant(language_id, is_root, domain, domain_redirect, route_code, is_default)
    values (1, false, 'localhost.cz', 'localhost', 'cs-cz', false);

    insert into const.nav_state(code, title) values ('HIDDEN', 'Hidden');
    insert into const.nav_state(code, title) values ('VISIBLE', 'Visible');

    insert into const.nav_type(code, title) values ('NOPAGE', 'Menu node without page');
    insert into const.nav_type(code, title) values ('DYNPAGE', 'Dynamic page');
    insert into const.nav_type(code, title) values ('STATPAGE', 'Static page');
    insert into const.nav_type(code, title) values ('EXT', 'External link');

    insert into const.article_state(code, title) values ('DRAFT', 'Draft');
    insert into const.article_state(code, title) values ('PUBLISHED', 'Published');

    insert into const.controller(code, name) values ('article', 'Article Controller');
    insert into const.controller(code, name) values ('download', 'Download Controller');
    insert into const.controller(code, name) values ('news', 'News Controller');
    insert into const.controller(code, name) values ('static', 'Static Controller');

    insert into const.route_map(language_id, route_path, controller_id) values (1, 'clanky', 3);
    insert into const.route_map(language_id, route_path, controller_id) values (1, 'stazeni', 2);
    insert into const.route_map(language_id, route_path, controller_id) values (1, 'novinky', 3);
    insert into const.route_map(language_id, route_path, controller_id) values (2, 'articles', 3);
    insert into const.route_map(language_id, route_path, controller_id) values (2, 'downloads', 2);
    insert into const.route_map(language_id, route_path, controller_id) values (2, 'news', 3);

    insert into public.settings(code, value) values ('image_directory', 'media/images');
    insert into public.settings(code, value) values ('upload_directory', 'upload');
    insert into public.settings(code, value) values ('thumbnail_sizes', '[75, 400]');
    insert into public.settings(code, value) values ('max_image_dimensions', '1600x1200');

    return query select 1;
end;
$$;

select *
from load_initial_data();